{"version":3,"names":["_proxies","require","_namespaces","_utils","stores","exports","Map","rawStores","storeLocks","storeConfigs","getConfig","namespace","get","getNamespace","universalUnlock","store","state","block","lock","has","set","rawStore","proxifyState","isPlainObject","proxifiedStore","proxifyStore","storeLock","isLockValid","Error","target","deepMerge","parseServerData","dom","document","_dom$getElementById","jsonDataScriptTag","getElementById","textContent","JSON","parse","populateServerData","data","Object","entries","forEach","st","config"],"sources":["@wordpress/interactivity/src/store.ts"],"sourcesContent":["/**\n * Internal dependencies\n */\nimport { proxifyState, proxifyStore } from './proxies';\n/**\n * External dependencies\n */\nimport { getNamespace } from './namespaces';\nimport { deepMerge, isPlainObject } from './utils';\n\nexport const stores = new Map();\nconst rawStores = new Map();\nconst storeLocks = new Map();\nconst storeConfigs = new Map();\n\n/**\n * Get the defined config for the store with the passed namespace.\n *\n * @param namespace Store's namespace from which to retrieve the config.\n * @return Defined config for the given namespace.\n */\nexport const getConfig = ( namespace?: string ) =>\n\tstoreConfigs.get( namespace || getNamespace() ) || {};\n\ninterface StoreOptions {\n\t/**\n\t * Property to block/unblock private store namespaces.\n\t *\n\t * If the passed value is `true`, it blocks the given namespace, making it\n\t * accessible only trough the returned variables of the `store()` call. In\n\t * the case a lock string is passed, it also blocks the namespace, but can\n\t * be unblocked for other `store()` calls using the same lock string.\n\t *\n\t * @example\n\t * ```\n\t * // The store can only be accessed where the `state` const can.\n\t * const { state } = store( 'myblock/private', { ... }, { lock: true } );\n\t * ```\n\t *\n\t * @example\n\t * ```\n\t * // Other modules knowing `SECRET_LOCK_STRING` can access the namespace.\n\t * const { state } = store(\n\t *   'myblock/private',\n\t *   { ... },\n\t *   { lock: 'SECRET_LOCK_STRING' }\n\t * );\n\t * ```\n\t */\n\tlock?: boolean | string;\n}\n\nexport const universalUnlock =\n\t'I acknowledge that using a private store means my plugin will inevitably break on the next store release.';\n\n/**\n * Extends the Interactivity API global store adding the passed properties to\n * the given namespace. It also returns stable references to the namespace\n * content.\n *\n * These props typically consist of `state`, which is the reactive part of the\n * store ― which means that any directive referencing a state property will be\n * re-rendered anytime it changes ― and function properties like `actions` and\n * `callbacks`, mostly used for event handlers. These props can then be\n * referenced by any directive to make the HTML interactive.\n *\n * @example\n * ```js\n *  const { state } = store( 'counter', {\n *    state: {\n *      value: 0,\n *      get double() { return state.value * 2; },\n *    },\n *    actions: {\n *      increment() {\n *        state.value += 1;\n *      },\n *    },\n *  } );\n * ```\n *\n * The code from the example above allows blocks to subscribe and interact with\n * the store by using directives in the HTML, e.g.:\n *\n * ```html\n * <div data-wp-interactive=\"counter\">\n *   <button\n *     data-wp-text=\"state.double\"\n *     data-wp-on--click=\"actions.increment\"\n *   >\n *     0\n *   </button>\n * </div>\n * ```\n * @param namespace The store namespace to interact with.\n * @param storePart Properties to add to the store namespace.\n * @param options   Options for the given namespace.\n *\n * @return A reference to the namespace content.\n */\nexport function store< S extends object = {} >(\n\tnamespace: string,\n\tstorePart?: S,\n\toptions?: StoreOptions\n): S;\n\nexport function store< T extends object >(\n\tnamespace: string,\n\tstorePart?: T,\n\toptions?: StoreOptions\n): T;\n\nexport function store(\n\tnamespace: string,\n\t{ state = {}, ...block }: any = {},\n\t{ lock = false }: StoreOptions = {}\n) {\n\tif ( ! stores.has( namespace ) ) {\n\t\t// Lock the store if the passed lock is different from the universal\n\t\t// unlock. Once the lock is set (either false, true, or a given string),\n\t\t// it cannot change.\n\t\tif ( lock !== universalUnlock ) {\n\t\t\tstoreLocks.set( namespace, lock );\n\t\t}\n\t\tconst rawStore = {\n\t\t\tstate: proxifyState(\n\t\t\t\tnamespace,\n\t\t\t\tisPlainObject( state ) ? state : {}\n\t\t\t),\n\t\t\t...block,\n\t\t};\n\t\tconst proxifiedStore = proxifyStore( namespace, rawStore );\n\t\trawStores.set( namespace, rawStore );\n\t\tstores.set( namespace, proxifiedStore );\n\t} else {\n\t\t// Lock the store if it wasn't locked yet and the passed lock is\n\t\t// different from the universal unlock. If no lock is given, the store\n\t\t// will be public and won't accept any lock from now on.\n\t\tif ( lock !== universalUnlock && ! storeLocks.has( namespace ) ) {\n\t\t\tstoreLocks.set( namespace, lock );\n\t\t} else {\n\t\t\tconst storeLock = storeLocks.get( namespace );\n\t\t\tconst isLockValid =\n\t\t\t\tlock === universalUnlock ||\n\t\t\t\t( lock !== true && lock === storeLock );\n\n\t\t\tif ( ! isLockValid ) {\n\t\t\t\tif ( ! storeLock ) {\n\t\t\t\t\tthrow Error( 'Cannot lock a public store' );\n\t\t\t\t} else {\n\t\t\t\t\tthrow Error(\n\t\t\t\t\t\t'Cannot unlock a private store with an invalid lock code'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst target = rawStores.get( namespace );\n\t\tdeepMerge( target, block );\n\t\tdeepMerge( target.state, state );\n\t}\n\n\treturn stores.get( namespace );\n}\n\nexport const parseServerData = ( dom = document ) => {\n\tconst jsonDataScriptTag =\n\t\t// Preferred Script Module data passing form\n\t\tdom.getElementById(\n\t\t\t'wp-script-module-data-@wordpress/interactivity'\n\t\t) ??\n\t\t// Legacy form\n\t\tdom.getElementById( 'wp-interactivity-data' );\n\tif ( jsonDataScriptTag?.textContent ) {\n\t\ttry {\n\t\t\treturn JSON.parse( jsonDataScriptTag.textContent );\n\t\t} catch {}\n\t}\n\treturn {};\n};\n\nexport const populateServerData = ( data?: {\n\tstate?: Record< string, unknown >;\n\tconfig?: Record< string, unknown >;\n} ) => {\n\tif ( isPlainObject( data?.state ) ) {\n\t\tObject.entries( data!.state ).forEach( ( [ namespace, state ] ) => {\n\t\t\tconst st = store< any >( namespace, {}, { lock: universalUnlock } );\n\t\t\tdeepMerge( st.state, state, false );\n\t\t} );\n\t}\n\tif ( isPlainObject( data?.config ) ) {\n\t\tObject.entries( data!.config ).forEach( ( [ namespace, config ] ) => {\n\t\t\tstoreConfigs.set( namespace, config );\n\t\t} );\n\t}\n};\n\n// Parse and populate the initial state and config.\nconst data = parseServerData();\npopulateServerData( data );\n"],"mappings":"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","ignoreList":[]}