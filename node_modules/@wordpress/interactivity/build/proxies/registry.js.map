{"version":3,"names":["objToProxy","WeakMap","proxyToNs","supported","Set","Object","Array","createProxy","namespace","obj","handlers","shouldProxy","Error","has","proxy","Proxy","set","get","exports","getProxyFromObject","getNamespaceFromProxy","candidate","constructor"],"sources":["@wordpress/interactivity/src/proxies/registry.ts"],"sourcesContent":["/**\n * Proxies for each object.\n */\nconst objToProxy = new WeakMap< object, object >();\n\n/**\n * Namespaces for each created proxy.\n */\nconst proxyToNs = new WeakMap< object, string >();\n\n/**\n * Object types that can be proxied.\n */\nconst supported = new Set( [ Object, Array ] );\n\n/**\n * Returns a proxy to the passed object with the given handlers, assigning the\n * specified namespace to it. If a proxy for the passed object was created\n * before, that proxy is returned.\n *\n * @param namespace The namespace that will be associated to this proxy.\n * @param obj       The object to proxify.\n * @param handlers  Handlers that the proxy will use.\n *\n * @throws Error if the object cannot be proxified. Use {@link shouldProxy} to\n *         check if a proxy can be created for a specific object.\n *\n * @return The created proxy.\n */\nexport const createProxy = < T extends object >(\n\tnamespace: string,\n\tobj: T,\n\thandlers: ProxyHandler< T >\n): T => {\n\tif ( ! shouldProxy( obj ) ) {\n\t\tthrow Error( 'This object cannot be proxified.' );\n\t}\n\tif ( ! objToProxy.has( obj ) ) {\n\t\tconst proxy = new Proxy( obj, handlers );\n\t\tobjToProxy.set( obj, proxy );\n\t\tproxyToNs.set( proxy, namespace );\n\t}\n\treturn objToProxy.get( obj ) as T;\n};\n\n/**\n * Returns the proxy for the given object. If there is no associated proxy, the\n * function returns `undefined`.\n *\n * @param obj Object from which to know the proxy.\n * @return Associated proxy or `undefined`.\n */\nexport const getProxyFromObject = < T extends object >( obj: T ): T =>\n\tobjToProxy.get( obj ) as T;\n\n/**\n * Gets the namespace associated with the given proxy.\n *\n * Proxies have a namespace assigned upon creation. See {@link createProxy}.\n *\n * @param proxy Proxy.\n * @return Namespace.\n */\nexport const getNamespaceFromProxy = ( proxy: object ): string =>\n\tproxyToNs.get( proxy )!;\n\n/**\n * Checks if a given object can be proxied.\n *\n * @param candidate Object to know whether it can be proxied.\n * @return True if the passed instance can be proxied.\n */\nexport const shouldProxy = (\n\tcandidate: any\n): candidate is Object | Array< unknown > => {\n\tif ( typeof candidate !== 'object' || candidate === null ) {\n\t\treturn false;\n\t}\n\treturn (\n\t\t! proxyToNs.has( candidate ) && supported.has( candidate.constructor )\n\t);\n};\n"],"mappings":";;;;;;AAAA;AACA;AACA;AACA,MAAMA,UAAU,GAAG,IAAIC,OAAO,CAAmB,CAAC;;AAElD;AACA;AACA;AACA,MAAMC,SAAS,GAAG,IAAID,OAAO,CAAmB,CAAC;;AAEjD;AACA;AACA;AACA,MAAME,SAAS,GAAG,IAAIC,GAAG,CAAE,CAAEC,MAAM,EAAEC,KAAK,CAAG,CAAC;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMC,WAAW,GAAGA,CAC1BC,SAAiB,EACjBC,GAAM,EACNC,QAA2B,KACpB;EACP,IAAK,CAAEC,WAAW,CAAEF,GAAI,CAAC,EAAG;IAC3B,MAAMG,KAAK,CAAE,kCAAmC,CAAC;EAClD;EACA,IAAK,CAAEZ,UAAU,CAACa,GAAG,CAAEJ,GAAI,CAAC,EAAG;IAC9B,MAAMK,KAAK,GAAG,IAAIC,KAAK,CAAEN,GAAG,EAAEC,QAAS,CAAC;IACxCV,UAAU,CAACgB,GAAG,CAAEP,GAAG,EAAEK,KAAM,CAAC;IAC5BZ,SAAS,CAACc,GAAG,CAAEF,KAAK,EAAEN,SAAU,CAAC;EAClC;EACA,OAAOR,UAAU,CAACiB,GAAG,CAAER,GAAI,CAAC;AAC7B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AANAS,OAAA,CAAAX,WAAA,GAAAA,WAAA;AAOO,MAAMY,kBAAkB,GAAyBV,GAAM,IAC7DT,UAAU,CAACiB,GAAG,CAAER,GAAI,CAAM;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPAS,OAAA,CAAAC,kBAAA,GAAAA,kBAAA;AAQO,MAAMC,qBAAqB,GAAKN,KAAa,IACnDZ,SAAS,CAACe,GAAG,CAAEH,KAAM,CAAE;;AAExB;AACA;AACA;AACA;AACA;AACA;AALAI,OAAA,CAAAE,qBAAA,GAAAA,qBAAA;AAMO,MAAMT,WAAW,GACvBU,SAAc,IAC8B;EAC5C,IAAK,OAAOA,SAAS,KAAK,QAAQ,IAAIA,SAAS,KAAK,IAAI,EAAG;IAC1D,OAAO,KAAK;EACb;EACA,OACC,CAAEnB,SAAS,CAACW,GAAG,CAAEQ,SAAU,CAAC,IAAIlB,SAAS,CAACU,GAAG,CAAEQ,SAAS,CAACC,WAAY,CAAC;AAExE,CAAC;AAACJ,OAAA,CAAAP,WAAA,GAAAA,WAAA","ignoreList":[]}